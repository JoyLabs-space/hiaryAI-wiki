---
title: エージェントの実行結果
description: Learn how to access the results and output from your agent run
---

import { Code } from '@astrojs/starlight/components';

export const handoffFinalOutputTypes = `import { Agent, Runner } from '@openai/agents';

// 異なる出力タイプを持つエージェントを定義
const dataAgent = new Agent({
  model: 'gpt-4o-mini',
  instructions: 'テキストから構造化データを抽出します。',
  outputTypes: {
    person: {
      type: 'object',
      properties: {
        name: { type: 'string' },
        age: { type: 'number' },
        occupation: { type: 'string' }
      },
      required: ['name']
    }
  }
});

const summaryAgent = new Agent({
  model: 'gpt-4o-mini',
  instructions: 'テキストの要約を提供します。',
  // outputTypesなし - デフォルトは文字列
});

const mainAgent = new Agent({
  model: 'gpt-4o-mini',
  instructions: 'タスクを適切なエージェントにルーティングします。',
  handoffs: [dataAgent, summaryAgent]
});

const runner = new Runner(mainAgent);
const result = await runner.run('情報を抽出: 田中さんは30歳でエンジニアとして働いています');

// どのエージェントが最終出力を提供したかをチェック
if (result.finalAgent === dataAgent) {
  // finalOutputはpersonスキーマに一致する解析されたJSONであるべき
  const personData = result.finalOutput as { name: string; age?: number; occupation?: string };
  console.log('抽出された人物:', personData.name);
} else if (result.finalAgent === summaryAgent) {
  // finalOutputは文字列であるべき
  const summary = result.finalOutput as string;
  console.log('要約:', summary);
}`;

export const historyLoop = `import { Agent, Runner } from '@openai/agents';

const agent = new Agent({
  model: 'gpt-4o-mini',
  instructions: '会話の記憶を持つ親切なアシスタントです。',
});

const runner = new Runner(agent);

// 空の履歴で開始
let messages = [];

while (true) {
  // ユーザー入力を取得（実際のアプリではUIから来ます）
  const userInput = await getUserInput();
  
  if (userInput === 'quit') break;

  // 会話履歴とともにエージェントを実行
  const result = await runner.run(userInput, {
    messages, // 以前の会話履歴を渡す
  });

  // 新しいやり取りで会話履歴を更新
  messages = result.messages;

  // エージェントの応答を表示
  console.log('エージェント:', result.finalOutput);
}

// 会話の特定部分にアクセスすることもできます
console.log('会話の総メッセージ数:', messages.length);

// ユーザーメッセージのみをフィルター
const userMessages = messages.filter(msg => msg.role === 'user');
console.log('ユーザーが言ったこと:', userMessages.map(m => m.content));

// アシスタントメッセージをフィルター
const assistantMessages = messages.filter(msg => msg.role === 'assistant');
console.log('アシスタントが言ったこと:', assistantMessages.map(m => m.content));`;

[エージェントの実行](/openai-agents-js/ja/guides/running-agents) を行うと、次のいずれかが返ります:

- [`RunResult`](/openai-agents-js/openai/agents/classes/runresult) — `stream: true` を指定せずに `run` を呼び出した場合
- [`StreamedRunResult`](/openai-agents-js/openai/agents/classes/streamedrunresult) — `stream: true` を指定して `run` を呼び出した場合。ストリーミングの詳細については、[ストリーミング](/openai-agents-js/ja/guides/streaming) も参照してください。

## 最終出力

`finalOutput` プロパティには、最後に実行されたエージェントの最終出力が含まれます。この結果は次のいずれかです:

- `string` — `outputType` が定義されていない任意のエージェントのデフォルト
- `unknown` — エージェントに出力タイプとして JSON スキーマが定義されている場合。この場合、 JSON は解析されていますが、型は手動で検証する必要があります
- `z.infer<outputType>` — エージェントに出力タイプとして Zod スキーマが定義されている場合。出力は自動的にこのスキーマに照らして解析されます
- `undefined` — エージェントが出力を生成しなかった場合（たとえば、出力を生成する前に停止した場合）

異なる出力タイプを持つハンドオフを使用している場合は、エージェントを作成する際に `new Agent()` コンストラクタではなく `Agent.create()` メソッドを使用してください。

これにより、 SDK があらゆるハンドオフにまたがる出力タイプを推論し、`finalOutput` プロパティに対して合併型を提供できるようになります。

例:

<Code
  lang="typescript"
  code={handoffFinalOutputTypes}
  title="ハンドオフの最終出力型"
/>

## 次のターンの入力

次のターンの入力にアクセスする方法は 2 通りあります:

- `result.history` — あなたの入力とエージェントの出力の両方のコピーを含みます
- `result.output` — エージェントの全実行の出力を含みます

`history` は、チャットのようなユースケースで完全な履歴を維持するのに便利です:

<Code lang="typescript" code={historyLoop} title="履歴ループ" />

## 最後のエージェント

`lastAgent` プロパティには、最後に実行されたエージェントが含まれます。アプリケーションによっては、次回ユーザーが何かを入力する際に役立つことがよくあります。たとえば、フロントラインのトリアージ エージェントが言語別のエージェントへハンドオフする場合、最後のエージェントを保存しておき、次回ユーザーがエージェントにメッセージを送るときに再利用できます。

ストリーミング モードでは、実行中の現在のエージェントに対応する `currentAgent` プロパティへアクセスするのも有用です。

## 新規アイテム

`newItems` プロパティには、実行中に生成された新しいアイテムが含まれます。アイテムは [`RunItem`](/openai-agents-js/openai/agents/type-aliases/runitem) です。実行アイテムは、 LLM が生成した元のアイテムをラップします。これらは、 LLM の出力に加えて、これらのイベントがどのエージェントに関連付けられていたかにアクセスするためにも使用できます。

- [`RunMessageOutputItem`](/openai-agents-js/openai/agents/classes/runmessageoutputitem) は、 LLM からのメッセージを示します。元のアイテムは生成されたメッセージです
- [`RunHandoffCallItem`](/openai-agents-js/openai/agents/classes/runhandoffcallitem) は、 LLM がハンドオフ ツールを呼び出したことを示します。元のアイテムは LLM からのツール呼び出しアイテムです
- [`RunHandoffOutputItem`](/openai-agents-js/openai/agents/classes/runhandoffoutputitem) は、ハンドオフが発生したことを示します。元のアイテムはハンドオフ ツール呼び出しへのツール応答です。アイテムからソース/ターゲットのエージェントにもアクセスできます
- [`RunToolCallItem`](/openai-agents-js/openai/agents/classes/runtoolcallitem) は、 LLM がツールを呼び出したことを示します
- [`RunToolCallOutputItem`](/openai-agents-js/openai/agents/classes/runtoolcalloutputitem) は、ツールが呼び出されたことを示します。元のアイテムはツールの応答です。アイテムからツール出力にもアクセスできます
- [`RunReasoningItem`](/openai-agents-js/openai/agents/classes/runreasoningitem) は、 LLM からの推論アイテムを示します。元のアイテムは生成された推論です
- [`RunToolApprovalItem`](/openai-agents-js/openai/agents/classes/runtoolapprovalitem) は、 LLM がツール呼び出しの承認を要求したことを示します。元のアイテムは LLM からのツール呼び出しアイテムです

## 状態

`state` プロパティには実行の状態が含まれます。`result` に付随するほとんどの情報は `state` から導出されますが、`state` はシリアライズ/デシリアライズ可能であり、[エラーからの回復](/openai-agents-js/ja/guides/running-agents#exceptions) が必要な場合や [`interruption`](#interruptions) に対処する必要がある場合に、後続の `run` 呼び出しの入力としても使用できます。

## 割り込み

エージェントで `needsApproval` を使用している場合、`run` は続行前に処理する必要がある `interruptions` をトリガーすることがあります。その場合、`interruptions` は割り込みを引き起こした `ToolApprovalItem` の配列になります。割り込みへの対処方法の詳細は、[人間の介入（HITL）](/openai-agents-js/ja/guides/human-in-the-loop) を参照してください。

## その他の情報

### 元のレスポンス

`rawResponses` プロパティには、エージェント実行中にモデルが生成した元の LLM レスポンスが含まれます。

### 最終レスポンス ID

`lastResponseId` プロパティには、エージェント実行中にモデルが最後に生成したレスポンスの ID が含まれます。

### ガードレールの結果

`inputGuardrailResults` と `outputGuardrailResults` プロパティには、存在する場合はガードレールの結果が含まれます。ガードレールの結果には、ログや保存を行いたい有用な情報が含まれることがあるため、利用できるようにしています。

### 元の入力

`input` プロパティには、run メソッドに提供した元の入力が含まれます。ほとんどの場合は不要ですが、必要に応じて利用できます。
